<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>קורא - שדות ראשונים</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;600;700&family=Frank+Ruhl+Libre:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="chat-component.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Assistant', 'Frank Ruhl Libre', serif;
            background-color: #F5F5DC;
            color: #3E2723;
            direction: rtl;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #556B2F 0%, #3E2723 100%);
            color: #F5F5DC;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .nav-controls {
            display: flex;
            gap: 0;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .nav-group {
            display: flex;
            gap: 0;
            align-items: center;
        }
        
        .nav-group:not(:last-child)::after {
            content: '';
            width: 1px;
            height: 28px;
            background: rgba(245, 245, 220, 0.3);
            margin: 0 0.75rem;
        }
        
        /* Grouped buttons - remove borders between them */
        .nav-group .btn-nav:not(:last-child),
        .nav-group .chapter-select:not(:last-child) {
            border-left: none;
            border-radius: 0;
        }
        
        /* First button in group - rounded on right side (RTL) */
        .nav-group .btn-nav:first-child,
        .nav-group .chapter-select:first-child {
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        
        /* Last button in group - rounded on left side (RTL) */
        .nav-group .btn-nav:last-child,
        .nav-group .chapter-select:last-child {
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }
        
        /* Single button in group - fully rounded */
        .nav-group .btn-nav:only-child,
        .nav-group .chapter-select:only-child {
            border-radius: 4px;
            border-left: 2px solid #F5F5DC;
        }
        
        /* Hover effect for grouped buttons */
        .nav-group .btn-nav:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            z-index: 1;
            position: relative;
        }
        
        .nav-group .chapter-select:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .chapter-select {
            padding: 0.5rem 1rem;
            border: 2px solid #F5F5DC;
            background: rgba(255, 255, 255, 0.1);
            color: #F5F5DC;
            border-radius: 4px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
        }

        .chapter-select option {
            background: #556B2F;
            color: #F5F5DC;
        }

        .btn-nav {
            background: rgba(255, 255, 255, 0.2);
            color: #F5F5DC;
            border: 2px solid #F5F5DC;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            transition: background 0.3s;
        }

        .btn-nav:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-nav:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .reader-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .reader-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }

        .pdf-side {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            position: sticky;
            top: 100px;
            height: fit-content;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }

        .text-side {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            line-height: 1.1;
            font-size: 1.1rem;
            white-space: pre-wrap;
        }

        .pdf-viewer {
            width: 100%;
            height: auto;
            border-radius: 4px;
        }

        .gallery-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 2px solid #F5F5DC;
        }

        .gallery-section h3 {
            color: #556B2F;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.5rem;
        }

        .gallery-item {
            cursor: pointer;
            border-radius: 4px;
            overflow: hidden;
            border: 2px solid #F5F5DC;
            transition: transform 0.3s;
        }

        .gallery-item:hover {
            transform: scale(1.05);
        }

        .gallery-item img {
            width: 100%;
            height: auto;
            display: block;
        }

        .page-info {
            text-align: center;
            color: #8B7355;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #8B7355;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-right: 4px solid #c62828;
        }

        .text-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #F5F5DC;
        }

        .btn-edit, .btn-save, .btn-cancel, .btn-justify {
            padding: 0.5rem 1rem;
            border: 2px solid #556B2F;
            background: #556B2F;
            color: #F5F5DC;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: background 0.3s;
        }

        .btn-justify.active {
            background: #3E2723;
            border-color: #3E2723;
            font-weight: 600;
        }

        .font-controls, .line-spacing-controls {
            display: flex;
            gap: 0;
            border: 2px solid #556B2F;
            border-radius: 4px;
            overflow: hidden;
        }

        .btn-control {
            padding: 0.5rem 0.75rem;
            border: none;
            background: #556B2F;
            color: #F5F5DC;
            cursor: pointer;
            font-family: inherit;
            font-size: 1rem;
            font-weight: bold;
            transition: background 0.3s;
            border-left: 1px solid rgba(245, 245, 220, 0.3);
        }

        .btn-control:first-child {
            border-left: none;
        }

        .btn-control:hover {
            background: #3E2723;
        }

        .btn-control:active {
            background: #2E1A1A;
        }

        .btn-edit:hover, .btn-save:hover {
            background: #3E2723;
            border-color: #3E2723;
        }

        .btn-cancel {
            background: #8B7355;
            border-color: #8B7355;
        }

        .btn-cancel:hover {
            background: #6B5A4A;
            border-color: #6B5A4A;
        }

        .save-status {
            margin-right: auto;
            color: #556B2F;
            font-weight: 600;
        }

        .save-status.success {
            color: #2e7d32;
        }

        .save-status.error {
            color: #c62828;
        }

        .segmented-control {
            display: flex;
            gap: 0;
            border: 2px solid #556B2F;
            border-radius: 4px;
            overflow: hidden;
            background: #556B2F;
        }

        .segmented-btn {
            padding: 0.5rem 0.75rem;
            border: none;
            background: transparent;
            color: #F5F5DC;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            transition: background 0.3s;
            border-left: 1px solid rgba(245, 245, 220, 0.3);
            flex: 1;
        }

        .segmented-btn:first-child {
            border-left: none;
        }

        .segmented-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .segmented-btn.active {
            background: #3E2723;
            font-weight: 600;
        }

        .verification-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border: 2px solid #8B7355;
            border-radius: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            margin-right: auto;
        }

        .verification-indicator:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .verification-indicator.verified {
            border-color: #2e7d32;
            background: rgba(46, 125, 50, 0.2);
        }

        .verification-indicator.unverified {
            border-color: #c62828;
            background: rgba(198, 40, 40, 0.2);
        }

        .verification-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .verification-indicator.verified .verification-dot {
            background-color: #2e7d32;
            box-shadow: 0 0 8px rgba(46, 125, 50, 0.6);
        }

        .verification-indicator.unverified .verification-dot {
            background-color: #c62828;
            box-shadow: 0 0 8px rgba(198, 40, 40, 0.6);
        }

        .verification-text {
            font-size: 0.9rem;
            font-weight: 600;
            color: #F5F5DC;
        }

        .text-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .text-edit {
            width: 100%;
            min-height: 400px;
            padding: 1rem;
            border: 2px solid #556B2F;
            border-radius: 4px;
            font-family: inherit;
            font-size: 1.1rem;
            line-height: 1.1;
            direction: rtl;
            resize: vertical;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .text-edit[contenteditable="true"] {
            text-align: right;
        }

        .text-edit:focus {
            outline: none;
            border-color: #3E2723;
            box-shadow: 0 0 0 3px rgba(85, 107, 47, 0.1);
        }
        
        .text-edit {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        /* Mobile responsive */
        @media (max-width: 968px) {
            .reader-layout {
                grid-template-columns: 1fr;
            }

            .pdf-side {
                position: relative;
                top: 0;
                max-height: none;
            }

            .header-content {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-controls {
                width: 100%;
                justify-content: center;
            }
        }

        /* Lightbox for gallery images */
        .lightbox {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            cursor: pointer;
        }

        .lightbox-content {
            margin: auto;
            display: block;
            width: 90%;
            max-width: 900px;
            margin-top: 5%;
        }

        .lightbox-close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>שדות ראשונים - קורא</h1>
            <div class="nav-controls">
                <div class="nav-group">
                    <a href="index.html" class="btn-nav" style="text-decoration: none; display: inline-block;">דף הבית</a>
                </div>
                <div class="nav-group">
                    <select class="chapter-select" id="bookSelect" onchange="goToBook()">
                        <option value="">בחר ספר...</option>
                    </select>
                </div>
                <div class="nav-group">
                    <select class="chapter-select" id="chapterSelect" onchange="goToChapter()">
                        <option value="">בחר פרק...</option>
                    </select>
                </div>
                <div class="nav-group">
                    <button class="btn-nav" id="prevBtn" onclick="navigatePage(-1)">עמוד קודם →</button>
                    <button class="btn-nav" id="nextBtn" onclick="navigatePage(1)">← עמוד הבא</button>
                </div>
            </div>
        </div>
    </div>

    <div class="reader-container">
        <div class="reader-layout">
            <div class="pdf-side">
                <div class="page-info" id="pageInfo">טוען...</div>
                <div id="pdfContainer">
                    <div class="loading">טוען מסמך...</div>
                </div>
                <div id="galleryContainer" class="gallery-section" style="display: none;">
                    <h3>תמונות נוספות</h3>
                    <div class="gallery-grid" id="galleryGrid"></div>
                </div>
            </div>
            <div class="text-side">
                <div class="text-controls" id="textControls" style="display: none;">
                    <div class="verification-indicator" id="verificationIndicator" onclick="toggleVerification()" title="לחץ כדי לסמן כנבדק/לא נבדק">
                        <span class="verification-dot" id="verificationDot"></span>
                        <span class="verification-text" id="verificationText">לא נבדק</span>
                    </div>
                    <button class="btn-edit" id="editBtn" onclick="toggleEditMode()">ערוך טקסט</button>
                    <button class="btn-justify" id="smartJustifyBtn" onclick="toggleSmartJustify()" style="display: none;" title="החלף בין טקסט מקורי ל-justified">Justify</button>
                    <div class="font-controls">
                        <button class="btn-control" onclick="adjustFontSize(-1)" title="הקטן גופן">-</button>
                        <button class="btn-control" onclick="adjustFontSize(1)" title="הגדל גופן">+</button>
                    </div>
                    <div class="line-spacing-controls">
                        <button class="btn-control" onclick="adjustLineHeight(0.1)" title="הגדל ריווח שורות">↑</button>
                        <button class="btn-control" onclick="adjustLineHeight(-0.1)" title="הקטן ריווח שורות">↓</button>
                    </div>
                    <button class="btn-save" id="saveBtn" onclick="saveText()" style="display: none;">שמור שינויים</button>
                    <button class="btn-cancel" id="cancelBtn" onclick="cancelEdit()" style="display: none;">בטל</button>
                    <span class="save-status" id="saveStatus"></span>
                </div>
                <div id="textContainer">
                    <div class="loading">טוען טקסט...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox for gallery images -->
    <div id="lightbox" class="lightbox" onclick="closeLightbox()">
        <span class="lightbox-close">&times;</span>
        <img class="lightbox-content" id="lightboxImg">
    </div>

    <script>
        // Book configuration
        let booksConfig = null;
        let currentBookId = 'sadot_rishonim'; // Default book
        let currentBook = null;
        let chapters = [];
        let currentPage = 0;
        let minPage = 0;
        let maxPage = 0;
        let isEditMode = false;
        let originalText = '';
        let currentPageStr = '';
        let isVerified = false;
        let currentFontSize = parseFloat(localStorage.getItem('textFontSize')) || 1.1;
        let currentLineHeight = parseFloat(localStorage.getItem('textLineHeight')) || 1.1;

        // Load books configuration
        async function loadBooksConfig() {
            // Get book from URL first (before loading config)
            const urlParams = new URLSearchParams(window.location.search);
            const bookParam = urlParams.get('book');
            const requestedBookId = bookParam || 'sadot_rishonim';
            
            try {
                // Try to load from API first (if server is running)
                // Add cache-busting parameter to prevent stale config
                const response = await fetch(`/api/books?t=${Date.now()}`);
                if (response.ok) {
                    booksConfig = await response.json();
                } else {
                    throw new Error('API not available');
                }
            } catch (error) {
                console.log('API not available, loading from config file...');
                // Fallback: load from books-config.json directly
                // Add cache-busting parameter to prevent browser caching
                try {
                    const response = await fetch(`books-config.json?t=${Date.now()}`);
                    if (!response.ok) {
                        throw new Error('Config file not found');
                    }
                    booksConfig = await response.json();
                } catch (error) {
                    console.error('Error loading books config:', error);
                    // Fallback to default
                    chapters = [];
                    init();
                    return;
                }
            }
            
            // Set the book ID from URL parameter
            currentBookId = requestedBookId;
            console.log(`Loading book: ${currentBookId} (requested: ${requestedBookId})`);
            
            currentBook = booksConfig.books[currentBookId];
            if (!currentBook) {
                console.error(`Book ${currentBookId} not found in config. Available books:`, Object.keys(booksConfig.books));
                currentBookId = 'sadot_rishonim';
                currentBook = booksConfig.books[currentBookId];
            }
            
            if (!currentBook) {
                console.error('Default book also not found!');
                chapters = [];
                init();
                return;
            }
            
            chapters = currentBook.chapters || [];
            maxPage = currentBook.maxPage || 0;
            
            console.log(`Loaded book: ${currentBook.name}, ${chapters.length} chapters, maxPage: ${maxPage}`);
            
            // Update header with book name
            document.querySelector('.header h1').textContent = `${currentBook.name} - קורא`;
            
            // Populate book selector
            populateBookSelector();
            
            // Initialize page
            init();
        }
        
        function populateBookSelector() {
            const bookSelect = document.getElementById('bookSelect');
            if (!bookSelect || !booksConfig) return;
            
            bookSelect.innerHTML = '<option value="">בחר ספר...</option>';
            
            Object.keys(booksConfig.books).forEach(bookId => {
                const book = booksConfig.books[bookId];
                const option = document.createElement('option');
                option.value = bookId;
                option.textContent = book.name;
                if (bookId === currentBookId) {
                    option.selected = true;
                }
                bookSelect.appendChild(option);
            });
        }
        
        function goToBook() {
            const bookSelect = document.getElementById('bookSelect');
            const selectedBookId = bookSelect.value;
            
            if (!selectedBookId || selectedBookId === currentBookId) {
                return;
            }
            
            // Get the selected book's first chapter or page 0
            const selectedBook = booksConfig.books[selectedBookId];
            let targetPage = 0;
            let targetChapter = 0;
            
            if (selectedBook && selectedBook.chapters && selectedBook.chapters.length > 0) {
                targetPage = selectedBook.chapters[0].page;
                targetChapter = selectedBook.chapters[0].number;
            }
            
            // Navigate to the new book
            window.location.href = `reader.html?book=${selectedBookId}&page=${targetPage}&chapter=${targetChapter}`;
        }

        // Initialize
        function init() {
            // Get page from URL
            const urlParams = new URLSearchParams(window.location.search);
            const pageParam = urlParams.get('page');
            const chapterParam = urlParams.get('chapter');
            
            if (pageParam) {
                currentPage = parseInt(pageParam);
            } else if (chapterParam && chapters.length > 0) {
                const chapter = chapters.find(c => c.number == chapterParam);
                if (chapter) {
                    currentPage = chapter.page;
                }
            } else if (chapters.length > 0) {
                // Default to first chapter
                currentPage = chapters[0].page;
            }

            // Populate chapter select
            const select = document.getElementById('chapterSelect');
            select.innerHTML = '<option value="">בחר פרק...</option>';
            
            if (chapters.length === 0) {
                select.innerHTML = '<option value="">אין פרקים זמינים</option>';
                select.disabled = true;
            } else {
                chapters.forEach(chapter => {
                    const option = document.createElement('option');
                    option.value = chapter.page;
                    const chapterLabel = chapter.number === 0 ? 'הקדמה' : `פרק ${chapter.number}`;
                    option.textContent = `${chapterLabel}: ${chapter.name} (עמוד ${chapter.page})`;
                    if (chapter.page === currentPage) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            }

            loadPage(currentPage);
        }

        function goToChapter() {
            const select = document.getElementById('chapterSelect');
            const page = parseInt(select.value);
            if (select.value !== '' && !isNaN(page)) {
                currentPage = page;
                loadPage(currentPage);
                updateURL();
            }
        }

        function navigatePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= minPage && newPage <= maxPage) {
                currentPage = newPage;
                loadPage(currentPage);
                updateURL();
            }
        }

        function updateURL() {
            // Find the chapter that contains this page (the chapter with the highest page number <= current page)
            let chapter = chapters.length > 0 ? chapters[0] : null;
            if (chapters.length > 0) {
                for (let i = chapters.length - 1; i >= 0; i--) {
                    if (chapters[i].page <= currentPage) {
                        chapter = chapters[i];
                        break;
                    }
                }
            }
            const url = new URL(window.location);
            url.searchParams.set('book', currentBookId);
            url.searchParams.set('page', currentPage);
            if (chapter) {
                url.searchParams.set('chapter', chapter.number);
            }
            window.history.pushState({}, '', url);
        }

        async function loadPage(page) {
            const pageStr = String(page).padStart(3, '0');
            
            // Update page info - find the chapter that contains this page
            let chapter = chapters.length > 0 ? chapters[0] : null;
            if (chapters.length > 0) {
                for (let i = chapters.length - 1; i >= 0; i--) {
                    if (chapters[i].page <= page) {
                        chapter = chapters[i];
                        break;
                    }
                }
            }
            const pageInfo = document.getElementById('pageInfo');
            if (chapter) {
                const chapterLabel = chapter.number === 0 ? 'הקדמה' : `פרק ${chapter.number}`;
                pageInfo.textContent = `${chapterLabel}: ${chapter.name} - עמוד ${page}`;
            } else {
                pageInfo.textContent = `עמוד ${page}`;
            }

            // Update navigation buttons
            document.getElementById('prevBtn').disabled = page <= minPage;
            document.getElementById('nextBtn').disabled = page >= maxPage;

            // Update chapter select
            const select = document.getElementById('chapterSelect');
            if (chapters.length > 0) {
                // Find the chapter that contains this page (the chapter with the highest page number <= current page)
                let currentChapter = chapters[0];
                for (let i = chapters.length - 1; i >= 0; i--) {
                    if (chapters[i].page <= page) {
                        currentChapter = chapters[i];
                        break;
                    }
                }
                select.value = currentChapter.page;
            }

            // Load PDF
            loadPDF(pageStr);

            // Load text
            loadText(pageStr);

            // Load gallery
            loadGallery(pageStr);
        }

        function loadPDF(pageStr) {
            const container = document.getElementById('pdfContainer');
            const pdfPath = `books/${currentBookId}/pdf_pages/${pageStr}.pdf`;
            // Add #view=Fit to fit entire PDF page to viewer (width and height)
            const pdfPathWithView = `${pdfPath}#view=Fit`;
            // Use object tag for better PDF display
            container.innerHTML = `
                <object data="${pdfPathWithView}" type="application/pdf" class="pdf-viewer" style="width: 100%; height: calc(100vh - 200px);">
                    <iframe src="${pdfPathWithView}" style="width: 100%; height: calc(100vh - 200px); border: none;"></iframe>
                </object>
            `;
        }

        async function loadText(pageStr) {
            const container = document.getElementById('textContainer');
            try {
                const textPath = `books/${currentBookId}/text/${pageStr}.txt`;
                // Try with padding first (e.g., 009.txt)
                let response = await fetch(textPath, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'text/plain; charset=utf-8'
                    }
                });
                
                // If not found, try without padding (e.g., 9.txt)
                if (!response.ok && response.status === 404) {
                    const pageNum = parseInt(pageStr);
                    if (pageNum.toString() !== pageStr) {
                        const textPathNoPad = `books/${currentBookId}/text/${pageNum}.txt`;
                        response = await fetch(textPathNoPad, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'text/plain; charset=utf-8'
                            }
                        });
                    }
                }
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`קובץ ${pageStr}.txt לא נמצא בספר ${currentBook.name}`);
                    } else {
                        throw new Error(`שגיאה בטעינת הקובץ (קוד שגיאה: ${response.status})`);
                    }
                }
                
                const text = await response.text();
                originalText = text;
                currentPageStr = pageStr;
                
                // Exit edit mode if we're loading a new page
                if (isEditMode) {
                    cancelEdit();
                }
                
                container.innerHTML = `<div class="text-content">${escapeHtml(text)}</div>`;
                
                // Apply text styles (font size, line height, and text align)
                applyTextStyles();
                
                // Show edit controls if text loaded successfully
                const controls = document.getElementById('textControls');
                if (controls) {
                    controls.style.display = 'flex';
                }
                
                // Load verification status
                await loadVerificationStatus(pageStr);
            } catch (error) {
                // CORS error or network error - provide helpful message
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    container.innerHTML = `
                        <div class="error">
                            <strong>בעיית CORS:</strong> יש להריץ את האתר דרך שרת מקומי.<br><br>
                            אפשרויות:<br>
                            1. Python: <code>python -m http.server 8000</code><br>
                            2. Node.js: <code>npx http-server</code><br>
                            3. פתח את האתר דרך: <code>http://localhost:8000</code>
                        </div>
                    `;
                } else {
                    container.innerHTML = `<div class="error">שגיאה בטעינת הטקסט: ${error.message}</div>`;
                }
                
                // Hide edit controls on error
                const controls = document.getElementById('textControls');
                if (controls) {
                    controls.style.display = 'none';
                }
                
                // Reset edit state
                isEditMode = false;
                originalText = '';
                currentPageStr = '';
            }
        }

        function toggleEditMode() {
            // Prevent editing if file is verified (locked)
            if (isVerified) {
                alert('קובץ זה נבדק ונעול לעריכה. יש לבטל את הסטטוס "נבדק" כדי לערוך.');
                return;
            }
            
            const container = document.getElementById('textContainer');
            const editBtn = document.getElementById('editBtn');
            const saveBtn = document.getElementById('saveBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const saveStatus = document.getElementById('saveStatus');
            
            if (!isEditMode) {
                // Enter edit mode - use contenteditable div instead of textarea for justify support
                isEditMode = true;
                const editDiv = document.createElement('div');
                editDiv.className = 'text-edit';
                editDiv.contentEditable = 'true';
                editDiv.textContent = originalText;
                container.innerHTML = '';
                container.appendChild(editDiv);
                
                // Apply text styles immediately
                setTimeout(() => {
                    applyTextStyles();
                }, 0);
                
                // Show smart justify button in edit mode
                const smartJustifyBtn = document.getElementById('smartJustifyBtn');
                if (smartJustifyBtn) {
                    smartJustifyBtn.style.display = 'inline-block';
                    smartJustifyBtn.textContent = 'Justify';
                    smartJustifyBtn.disabled = false;
                }
                
                editBtn.style.display = 'none';
                saveBtn.style.display = 'inline-block';
                cancelBtn.style.display = 'inline-block';
                saveStatus.textContent = '';
            }
        }
        
        function cancelEdit() {
            const container = document.getElementById('textContainer');
            const editBtn = document.getElementById('editBtn');
            const saveBtn = document.getElementById('saveBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const saveStatus = document.getElementById('saveStatus');
            
            isEditMode = false;
            container.innerHTML = `<div class="text-content">${escapeHtml(originalText)}</div>`;
            
            // Apply text styles
            applyTextStyles();
            
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            saveStatus.textContent = '';
            
            // Hide smart justify button when canceling edit
            const smartJustifyBtn = document.getElementById('smartJustifyBtn');
            if (smartJustifyBtn) {
                smartJustifyBtn.style.display = 'none';
            }
        }
        
        async function saveText() {
            // Prevent saving if file is verified (locked)
            if (isVerified) {
                const saveStatus = document.getElementById('saveStatus');
                saveStatus.textContent = 'שגיאה: קובץ נבדק ונעול - לא ניתן לשמור';
                saveStatus.className = 'save-status error';
                return;
            }
            
            const container = document.getElementById('textContainer');
            const textEdit = container.querySelector('.text-edit');
            const saveBtn = document.getElementById('saveBtn');
            const saveStatus = document.getElementById('saveStatus');
            
            if (!textEdit) {
                return;
            }
            
            // Get text from contenteditable div or textarea
            let editedText;
            if (textEdit.contentEditable === 'true') {
                // Walk through DOM nodes to properly extract text with newlines
                // This preserves <br> tags and block elements (div, p) as actual newlines
                function extractTextWithNewlines(node) {
                    let text = '';
                    for (let child of node.childNodes) {
                        if (child.nodeType === Node.TEXT_NODE) {
                            text += child.textContent;
                        } else if (child.nodeType === Node.ELEMENT_NODE) {
                            const tagName = child.tagName ? child.tagName.toUpperCase() : '';
                            
                            // Handle line breaks
                            if (tagName === 'BR') {
                                text += '\n';
                            } 
                            // Handle block elements (div, p) - they represent newlines
                            else if (tagName === 'DIV' || tagName === 'P') {
                                // Add newline before block element content (except first)
                                if (text && !text.endsWith('\n')) {
                                    text += '\n';
                                }
                                text += extractTextWithNewlines(child);
                                // Add newline after block element (except last)
                                if (!text.endsWith('\n')) {
                                    text += '\n';
                                }
                            } 
                            // Handle other elements recursively
                            else {
                                text += extractTextWithNewlines(child);
                            }
                        }
                    }
                    return text;
                }
                
                editedText = extractTextWithNewlines(textEdit);
                
                // Clean up: remove multiple consecutive newlines (keep max 2 for paragraph breaks)
                editedText = editedText.replace(/\n{3,}/g, '\n\n');
                
                // Normalize newlines (handle Windows \r\n and Mac \r)
                editedText = editedText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                
                // Trim trailing newlines
                editedText = editedText.replace(/\n+$/, '');
            } else {
                editedText = textEdit.value;
            }
            
            // Validate text
            if (!editedText && editedText !== '') {
                saveStatus.textContent = 'שגיאה: לא ניתן לשמור טקסט ריק';
                saveStatus.className = 'save-status error';
                return;
            }
            
            // Disable save button during save
            saveBtn.disabled = true;
            saveStatus.textContent = 'שומר...';
            saveStatus.className = 'save-status';
            
            try {
                const response = await fetch('/api/save-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        bookId: currentBookId,
                        page: currentPageStr,
                        text: editedText
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(errorData.error || `שגיאה בשמירה (קוד: ${response.status})`);
                }
                
                const result = await response.json();
                
                // Update original text
                originalText = editedText;
                
                // Exit edit mode and show success
                isEditMode = false;
                container.innerHTML = `<div class="text-content">${escapeHtml(editedText)}</div>`;
                
                // Apply text styles
                applyTextStyles();
                
                const editBtn = document.getElementById('editBtn');
                const cancelBtn = document.getElementById('cancelBtn');
                const smartJustifyBtn = document.getElementById('smartJustifyBtn');
                editBtn.style.display = 'inline-block';
                saveBtn.style.display = 'none';
                cancelBtn.style.display = 'none';
                if (smartJustifyBtn) {
                    smartJustifyBtn.style.display = 'none';
                }
                
                saveStatus.textContent = 'נשמר בהצלחה!';
                saveStatus.className = 'save-status success';
                
                // Clear success message after 3 seconds
                setTimeout(() => {
                    saveStatus.textContent = '';
                }, 3000);
                
            } catch (error) {
                saveStatus.textContent = `שגיאה: ${error.message}`;
                saveStatus.className = 'save-status error';
            } finally {
                saveBtn.disabled = false;
            }
        }
        
        async function loadVerificationStatus(pageStr) {
            try {
                const response = await fetch(`/api/verification/${currentBookId}/${pageStr}`);
                if (response.ok) {
                    const data = await response.json();
                    isVerified = data.verified || false;
                } else {
                    isVerified = false;
                }
            } catch (error) {
                console.error('Error loading verification status:', error);
                isVerified = false;
            }
            updateVerificationUI();
        }
        
        function updateVerificationUI() {
            const indicator = document.getElementById('verificationIndicator');
            const dot = document.getElementById('verificationDot');
            const text = document.getElementById('verificationText');
            const editBtn = document.getElementById('editBtn');
            
            if (!indicator) return;
            
            if (isVerified) {
                indicator.className = 'verification-indicator verified';
                text.textContent = 'נבדק';
                // Disable edit button when verified (locked)
                if (editBtn) {
                    editBtn.disabled = true;
                    editBtn.title = 'קובץ נבדק ונעול - יש לבטל את הסטטוס "נבדק" כדי לערוך';
                    editBtn.style.opacity = '0.5';
                    editBtn.style.cursor = 'not-allowed';
                }
            } else {
                indicator.className = 'verification-indicator unverified';
                text.textContent = 'לא נבדק';
                // Enable edit button when not verified
                if (editBtn) {
                    editBtn.disabled = false;
                    editBtn.title = 'ערוך טקסט';
                    editBtn.style.opacity = '1';
                    editBtn.style.cursor = 'pointer';
                }
            }
        }
        
        async function toggleVerification() {
            const newStatus = !isVerified;
            
            // If verifying (locking), exit edit mode if currently editing
            if (newStatus && isEditMode) {
                if (!confirm('הקובץ יסומן כנבדק ונעול. כל שינויים שלא נשמרו יאבדו. להמשיך?')) {
                    return;
                }
                cancelEdit();
            }
            
            try {
                const response = await fetch('/api/verification', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        bookId: currentBookId,
                        page: currentPageStr,
                        verified: newStatus
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(errorData.error || 'שגיאה בשמירת סטטוס האימות');
                }
                
                isVerified = newStatus;
                updateVerificationUI();
                
            } catch (error) {
                console.error('Error toggling verification:', error);
                alert(`שגיאה: ${error.message}`);
            }
        }
        
        function adjustFontSize(delta) {
            currentFontSize += delta * 0.1;
            // Limit font size between 0.8rem and 2.0rem
            currentFontSize = Math.max(0.8, Math.min(2.0, currentFontSize));
            localStorage.setItem('textFontSize', currentFontSize.toString());
            applyTextStyles();
        }
        
        function adjustLineHeight(delta) {
            currentLineHeight += delta;
            // Limit line height between 0 and 2.5
            currentLineHeight = Math.max(0, Math.min(2.5, currentLineHeight));
            localStorage.setItem('textLineHeight', currentLineHeight.toString());
            applyTextStyles();
        }
        
        async function toggleSmartJustify() {
            const textEdit = document.querySelector('.text-edit');
            if (!textEdit || textEdit.contentEditable !== 'true') return;
            
            const smartJustifyBtn = document.getElementById('smartJustifyBtn');
            
            // Check if already justified
            const isJustified = textEdit.dataset.justified === 'true';
            
            if (!isJustified) {
                // First time - save original to .orig file
                const originalText = textEdit.textContent || textEdit.innerText;
                
                try {
                    // Save original text to .orig file
                    const response = await fetch('/api/save-orig', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            bookId: currentBookId,
                            page: currentPageStr,
                            text: originalText
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                        console.error('Error response:', errorData);
                        throw new Error(errorData.error || `Failed to save original file (status: ${response.status})`);
                    }
                    
                    // Store original text in dataset
                    textEdit.dataset.originalText = originalText;
                    textEdit.dataset.justified = 'true';
                    
                    // Apply justify
                    applySmartBookJustify(textEdit);
                    
                    if (smartJustifyBtn) {
                        smartJustifyBtn.textContent = 'Justify (מקורי)';
                    }
                } catch (error) {
                    console.error('Error saving original file:', error);
                    console.error('Error details:', error.message, error.stack);
                    alert(`שגיאה בשמירת הקובץ המקורי: ${error.message}\n\nנסה לבדוק את ה-console לפרטים נוספים.`);
                }
            } else {
                // Toggle back to original
                if (textEdit.dataset.originalText) {
                    textEdit.textContent = textEdit.dataset.originalText;
                    textEdit.dataset.justified = 'false';
                    
                    if (smartJustifyBtn) {
                        smartJustifyBtn.textContent = 'Justify';
                    }
                }
            }
        }
        
        function applyTextStyles() {
            const textContainer = document.getElementById('textContainer');
            const textContent = textContainer.querySelector('.text-content');
            const textEdit = textContainer.querySelector('.text-edit');
            
            if (textContent) {
                textContent.style.fontSize = `${currentFontSize}rem`;
                textContent.style.lineHeight = currentLineHeight.toString();
                textContent.style.setProperty('text-align', 'right', 'important');
            }
            
            if (textEdit) {
                textEdit.style.fontSize = `${currentFontSize}rem`;
                textEdit.style.lineHeight = currentLineHeight.toString();
                textEdit.style.setProperty('text-align', 'right', 'important');
                textEdit.style.setProperty('text-align-last', 'right', 'important');
                // Remove any justify-related styles
                textEdit.style.removeProperty('text-justify');
                textEdit.style.removeProperty('word-spacing');
                textEdit.style.removeProperty('letter-spacing');
            }
        }
        
        function getTextFromEdit() {
            const textEdit = document.querySelector('.text-edit');
            if (textEdit) {
                // If it's contenteditable div, use textContent or innerText
                if (textEdit.contentEditable === 'true') {
                    // Get text - return original if stored (without extra spaces), otherwise current text
                    if (textEdit.dataset.originalText) {
                        return textEdit.dataset.originalText;
                    }
                    const text = textEdit.textContent || textEdit.innerText;
                    return text;
                } else {
                    // If it's textarea, use value
                    return textEdit.value;
                }
            }
            return '';
        }
        
        // Store original text before justify processing
        let originalTextBeforeJustify = '';
        
        function applySmartBookJustify(element) {
            if (!element || element.contentEditable !== 'true') return;
            
            // Store original text if not already stored
            if (!element.dataset.originalText) {
                originalTextBeforeJustify = element.textContent || element.innerText;
                element.dataset.originalText = originalTextBeforeJustify;
            } else {
                originalTextBeforeJustify = element.dataset.originalText;
            }
            
            // Create a reusable measurement element once (more efficient)
            const measureSpan = document.createElement('span');
            const computedStyle = window.getComputedStyle(element);
            
            // Copy all relevant styles from the element to ensure accurate measurement
            measureSpan.style.visibility = 'hidden';
            measureSpan.style.position = 'absolute';
            measureSpan.style.whiteSpace = 'nowrap';
            measureSpan.style.fontSize = computedStyle.fontSize;
            measureSpan.style.fontFamily = computedStyle.fontFamily;
            measureSpan.style.fontWeight = computedStyle.fontWeight;
            measureSpan.style.fontStyle = computedStyle.fontStyle;
            measureSpan.style.letterSpacing = computedStyle.letterSpacing;
            measureSpan.style.wordSpacing = computedStyle.wordSpacing;
            measureSpan.style.direction = computedStyle.direction || 'rtl';
            measureSpan.style.textTransform = computedStyle.textTransform;
            measureSpan.style.fontVariant = computedStyle.fontVariant;
            
            // Ensure it's in the DOM and rendered
            document.body.appendChild(measureSpan);
            
            // Force a reflow to ensure styles are applied
            measureSpan.offsetHeight;
            
            // Helper function to measure text width using the reusable element
            const measureTextWidth = (text) => {
                measureSpan.textContent = text;
                // Force a reflow to ensure measurement is accurate
                const width = measureSpan.offsetWidth;
                
                // If width is 0, try alternative measurement methods
                if (width === 0 && text.length > 0) {
                    // Try using getBoundingClientRect as fallback
                    const rect = measureSpan.getBoundingClientRect();
                    if (rect.width > 0) {
                        return rect.width;
                    }
                    // If still 0, log warning and return a fallback estimate
                    console.warn(`Could not measure width for text: "${text.substring(0, 20)}..."`);
                    return null;
                }
                
                return width;
            };
            
            // Split text into lines, preserving empty lines
            const allLines = originalTextBeforeJustify.split('\n');
            
            // Group lines into paragraphs (paragraphs are separated by empty lines)
            const paragraphs = [];
            let currentParagraph = [];
            
            for (let i = 0; i < allLines.length; i++) {
                const line = allLines[i];
                if (line.trim() === '' && currentParagraph.length > 0) {
                    // Empty line after non-empty content - end current paragraph
                    paragraphs.push(currentParagraph);
                    currentParagraph = [];
                } else if (line.trim() !== '') {
                    // Non-empty line - add to current paragraph
                    currentParagraph.push(line);
                } else if (line.trim() === '' && currentParagraph.length === 0) {
                    // Empty line at start or between paragraphs - preserve as empty paragraph
                    paragraphs.push([]);
                }
            }
            // Add last paragraph if exists
            if (currentParagraph.length > 0) {
                paragraphs.push(currentParagraph);
            }
            
            let processedHTML = '';
            
            paragraphs.forEach((paragraph, paraIndex) => {
                // Empty paragraph (empty line) - just add line break
                if (paragraph.length === 0) {
                    processedHTML += '<br>';
                    return;
                }
                
                const lines = paragraph;
                
                if (lines.length === 0) {
                    processedHTML += '<br><br>';
                    return;
                }
                
                // Find the longest line by actual rendered width (excluding last line)
                const linesToProcess = lines.slice(0, -1); // All except last line
                if (linesToProcess.length === 0) {
                    // Only one line, don't modify
                    processedHTML += lines[0] + '<br>';
                    return;
                }
                
                // Measure actual rendered width for each line
                const lineData = linesToProcess.map(line => {
                    const trimmed = line.trim();
                    const width = measureTextWidth(trimmed);
                    return {
                        line: trimmed,
                        width: width
                    };
                }).filter(l => l.width !== null && l.width > 0); // Filter out invalid measurements
                
                // If no valid measurements, fall back to character-based
                if (lineData.length === 0) {
                    console.warn('Could not measure any lines, using character-based fallback');
                    const maxLength = Math.max(...linesToProcess.map(l => l.trim().length));
                    linesToProcess.forEach(line => {
                        const trimmed = line.trim();
                        if (trimmed.length === maxLength) {
                            processedHTML += trimmed + '<br>';
                        } else {
                            // Simple character-based justification
                            const words = trimmed.split(/\s+/).filter(w => w.trim());
                            if (words.length <= 1) {
                                processedHTML += trimmed + '<br>';
                            } else {
                                const charsToAdd = maxLength - trimmed.length;
                                const gaps = words.length - 1;
                                const baseSpaces = Math.floor(charsToAdd / gaps);
                                const remainder = charsToAdd % gaps;
                                let processedLine = '';
                                for (let i = 0; i < words.length; i++) {
                                    processedLine += words[i];
                                    if (i < words.length - 1) {
                                        let spaces = 1 + baseSpaces + (i < remainder ? 1 : 0);
                                        spaces = Math.max(0, Math.min(spaces, 100));
                                        processedLine += ' '.repeat(spaces);
                                    }
                                }
                                processedHTML += processedLine + '<br>';
                            }
                        }
                    });
                    return; // Exit early
                }
                
                // Find the longest line by actual width
                const maxWidth = Math.max(...lineData.map(l => l.width));
                
                // Measure width of a single space - try multiple methods for reliability
                let singleSpaceWidth = measureTextWidth(' ');
                
                // If direct measurement fails, try measuring "a a" vs "aa" and calculating difference
                if (!singleSpaceWidth || singleSpaceWidth <= 0 || !isFinite(singleSpaceWidth)) {
                    const widthAA = measureTextWidth('aa');
                    const widthA_A = measureTextWidth('a a');
                    if (widthAA && widthA_A && widthA_A > widthAA) {
                        singleSpaceWidth = widthA_A - widthAA;
                        console.log(`Calculated space width from difference: ${singleSpaceWidth}px`);
                    }
                }
                
                // If still invalid, try measuring a longer string with spaces
                if (!singleSpaceWidth || singleSpaceWidth <= 0 || !isFinite(singleSpaceWidth)) {
                    const widthWithSpaces = measureTextWidth('     '); // 5 spaces
                    if (widthWithSpaces && widthWithSpaces > 0) {
                        singleSpaceWidth = widthWithSpaces / 5;
                        console.log(`Calculated space width from 5 spaces: ${singleSpaceWidth}px`);
                    }
                }
                
                // Validate singleSpaceWidth - if it's still 0 or invalid, fall back to character-based approach
                if (!singleSpaceWidth || singleSpaceWidth <= 0 || !isFinite(singleSpaceWidth)) {
                    console.warn('Could not measure space width, using character-based fallback');
                    // Fallback: use character count method
                    const maxLength = Math.max(...lineData.map(l => l.line.length));
                    lineData.forEach((lineInfo) => {
                        const line = lineInfo.line;
                        const currentLength = line.length;
                        
                        if (currentLength === maxLength) {
                            processedHTML += line + '<br>';
                            return;
                        }
                        
                        const charsToAdd = maxLength - currentLength;
                        if (charsToAdd <= 0) {
                            processedHTML += line + '<br>';
                            return;
                        }
                        
                        const words = line.split(/\s+/).filter(w => w.trim().length > 0);
                        const wordCount = words.length;
                        
                        if (wordCount <= 1) {
                            processedHTML += line + '<br>';
                            return;
                        }
                        
                        const gaps = wordCount - 1;
                        const baseSpacesPerGap = Math.floor(charsToAdd / gaps);
                        const remainder = charsToAdd % gaps;
                        
                        let processedLine = '';
                        for (let i = 0; i < words.length; i++) {
                            processedLine += words[i];
                            if (i < words.length - 1) {
                                let spacesToInsert = 1 + baseSpacesPerGap;
                                if (i < remainder) {
                                    spacesToInsert += 1;
                                }
                                // Safety check before repeat
                                spacesToInsert = Math.max(0, Math.min(spacesToInsert, 100)); // Limit to reasonable value
                                processedLine += ' '.repeat(spacesToInsert);
                            }
                        }
                        processedHTML += processedLine + '<br>';
                    });
                    return; // Exit early for fallback
                }
                
                // Process each line (except last) - justify all to maxWidth
                lineData.forEach((lineInfo) => {
                    const line = lineInfo.line;
                    const currentWidth = lineInfo.width;
                    
                    // If already at max width (within 2px tolerance), no need to modify
                    if (Math.abs(currentWidth - maxWidth) < 2) {
                        processedHTML += line + '<br>';
                        return;
                    }
                    
                    // Calculate how much width we need to add
                    const widthToAdd = maxWidth - currentWidth;
                    
                    if (widthToAdd <= 0 || !isFinite(widthToAdd)) {
                        processedHTML += line + '<br>';
                        return;
                    }
                    
                    // Split line into words (only actual words, not spaces)
                    const words = line.split(/\s+/).filter(w => w.trim().length > 0);
                    const wordCount = words.length;
                    
                    if (wordCount <= 1) {
                        processedHTML += line + '<br>';
                        return;
                    }
                    
                    // Calculate how many spaces we need to add
                    const totalSpacesToAdd = Math.round(widthToAdd / singleSpaceWidth);
                    
                    // Validate totalSpacesToAdd
                    if (!isFinite(totalSpacesToAdd) || totalSpacesToAdd <= 0 || totalSpacesToAdd > 1000) {
                        console.warn(`Invalid totalSpacesToAdd: ${totalSpacesToAdd}, skipping line`);
                        processedHTML += line + '<br>';
                        return;
                    }
                    
                    // Distribute spaces evenly between word gaps
                    const gaps = wordCount - 1;
                    if (gaps <= 0) {
                        processedHTML += line + '<br>';
                        return;
                    }
                    
                    const baseSpacesPerGap = Math.floor(totalSpacesToAdd / gaps);
                    const remainder = totalSpacesToAdd % gaps;
                    
                    // Build line with distributed spaces
                    let processedLine = '';
                    
                    for (let i = 0; i < words.length; i++) {
                        processedLine += words[i];
                        
                        // Add spaces after word (except for last word)
                        if (i < words.length - 1) {
                            // Base space (1) + extra spaces to reach target width
                            let spacesToInsert = 1 + baseSpacesPerGap;
                            
                            // Distribute remainder spaces to first few gaps
                            if (i < remainder) {
                                spacesToInsert += 1;
                            }
                            
                            // Safety check: ensure spacesToInsert is a valid finite number
                            spacesToInsert = Math.max(0, Math.min(Math.floor(spacesToInsert), 100)); // Limit to 0-100
                            
                            if (isFinite(spacesToInsert) && spacesToInsert > 0) {
                                processedLine += ' '.repeat(spacesToInsert);
                            } else {
                                processedLine += ' '; // Fallback to single space
                            }
                        }
                    }
                    
                    // Verify the width matches (for debugging)
                    const finalWidth = measureTextWidth(processedLine);
                    if (Math.abs(finalWidth - maxWidth) > 3) {
                        console.warn(`Width mismatch: expected ${maxWidth}px, got ${finalWidth}px`);
                    }
                    
                    processedHTML += processedLine + '<br>';
                });
                
                // Add last line of paragraph without modification
                processedHTML += lines[lines.length - 1];
                // Add line break after paragraph (empty lines between paragraphs are handled as separate paragraphs)
                processedHTML += '<br>';
            });
            
            // Clean up the measurement element
            document.body.removeChild(measureSpan);
            
            // Apply the processed HTML
            element.innerHTML = processedHTML;
        }
        
        function removeSmartBookJustify(element) {
            if (!element) return;
            // Restore original text
            if (element.dataset.originalText) {
                element.textContent = element.dataset.originalText;
                delete element.dataset.originalText;
            }
        }
        
        function removeExtraJustifySpaces(text) {
            // Remove multiple consecutive spaces, keep single spaces
            return text.replace(/  +/g, ' ').replace(/\n\s*\n\s*\n+/g, '\n\n');
        }
        
        async function loadGallery(pageStr) {
            const galleryContainer = document.getElementById('galleryContainer');
            const galleryGrid = document.getElementById('galleryGrid');
            
            // Check if gallery directory exists (we'll simulate this by checking common image extensions)
            // In a real implementation, you'd need a backend API to check directory existence
            galleryGrid.innerHTML = '';
            galleryContainer.style.display = 'none';
            
            // For now, we'll assume gallery images might exist
            // You can implement actual directory checking with a backend service
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/\n/g, '<br>');
        }

        function openLightbox(imgSrc) {
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.getElementById('lightboxImg');
            lightboxImg.src = imgSrc;
            lightbox.style.display = 'block';
        }

        function closeLightbox() {
            document.getElementById('lightbox').style.display = 'none';
        }

        // Handle browser back/forward
        window.addEventListener('popstate', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const bookParam = urlParams.get('book');
            const pageParam = urlParams.get('page');
            
            // If book changed, reload config
            if (bookParam && bookParam !== currentBookId) {
                loadBooksConfig();
            } else if (pageParam) {
                currentPage = parseInt(pageParam);
                loadPage(currentPage);
            }
        });

        // Initialize on load - load books config first
        loadBooksConfig();
    </script>
    <script src="chat-component.js"></script>
</body>
</html>

